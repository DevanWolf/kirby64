#include <ultra64.h>
#include <macros.h>
#include "ovl1/ovl1_6.h"
#include "D_8004A7C4.h"

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
Failed to decompile function func_80151100_ovl4:

Unable to determine jump table for jr instruction at /home/faris/kirby_decomp/asm/non_matchings/ovl4/ovl4/func_80151100_ovl4.s line 24.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl"/"jpt_".
#else
GLOBAL_ASM("asm/non_matchings/ovl4/ovl4/func_80151100_ovl4.s")
#endif

extern f32 D_80159FF4_ovl4[];
extern f32 D_8015C4DC;
extern const f32 D_8015C4D8;

void func_80151274_ovl4(void) {
    f32 temp_f0;
    s32 tmp;

    gEntitiesPosZArray[D_8004A7C4->objId] = 0.0f;
    tmp = random_soft_u16();
    temp_f0 = D_8015C4D8;
    gEntitiesAngleYArray[D_8004A7C4->objId] = (D_80159FF4_ovl4[tmp & 7] * D_8015C4DC) / 180.0f;
    D_800E4550[D_8004A7C4->objId] = temp_f0;
    D_800E4710[D_8004A7C4->objId] = temp_f0;
    D_800E48D0[D_8004A7C4->objId] = temp_f0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
Failed to decompile function func_80151338_ovl4:

Unable to determine jump table for jr instruction at /home/faris/kirby_decomp/asm/non_matchings/ovl4/ovl4/func_80151338_ovl4.s line 32.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl"/"jpt_".
#else
GLOBAL_ASM("asm/non_matchings/ovl4/ovl4/func_80151338_ovl4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_80151990_ovl4(s32 arg0) {
    random_u16();
    random_soft_u16();
    if ((D_800D6B24 == 0) && ((D_80048F22 & 0x9000) != 0)) {
        func_800A7678(0xED);
        func_800A57A0(0, 0, 0);
        func_800A5A14(0, 0x10, 2);
        D_800D6B74 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl4/ovl4/func_80151990_ovl4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_80151A0C_ovl4(s32 arg0) {
    s32 temp_t0;
    void *phi_return;

    random_u16();
    random_soft_u16();
    D_800BE4EC = D_800BE4EC + 1;
    phi_return = &D_8015C680;
    if (D_800D6B24 == 0) {
        temp_t0 = D_8015C680 - 1;
        D_8015C680 = temp_t0;
        if (temp_t0 < 0) {
            D_800D6B74 = 2;
            func_800A57A0(0, 0, 0);
            return func_800A5A14(0, 0x10, 2);
        }
        phi_return = &D_80048F20;
        if ((D_80048F20.unk2 & 0x9000) != 0) {
            if ((D_80048F20.unk0 & 0x2030) == 0x2030) {
                func_800A7678(0xE2);
            } else {
                func_800A7678(0xED);
            }
            func_800A57A0(0, 0, 0);
            phi_return = func_800A5A14(0, 0x10, 2);
        }
    }
    return phi_return;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl4/ovl4/func_80151A0C_ovl4.s")
#endif

extern s32 D_800D6B5C;
extern s16 D_800D6B30;
extern struct UnkStruct8004A7C4 *func_8000BDF0(s32 arg0, s32 arg1, s32 arg2, struct UnkStruct8004A7C4_3C_80 *arg3, s32 arg4);

extern void func_80007C00(f32 *, f32, f32, f32, f32);

void func_80151B08_ovl4(void) {
    s32 temp_s0;
    s32 temp_v1;
    s32 phi_s0;

    func_80007C00(&func_8000BDF0(0x19, 0x80000000, 0x63, 3, 0xFF)->unk3C->unk0.z,
                  10.0f,
                  10.0f,
                  310.0f,
                  230.0f
                 );
    func_800AE048(0x40);
    func_800AE0F0();
    func_800A6E64();
    func_800A8724(0);
    func_800A6BC0(0);
    switch (D_800D6B5C) {
        case 0:
            D_800E98E0[func_800AEC70(0, 0x3C, 0x70)] = 0;
            break;
        case 1:
            D_800E98E0[func_800AEC70(0, 0x3C, 0x70)] = 2;
            for (phi_s0 = 4; phi_s0 < 9; phi_s0++) {
                D_800E98E0[func_800AEC08(0, 0x3C, 0x70)] = phi_s0;
            }
            break;
        case 4:
            D_800E98E0[func_800AEC70(0, 0x3C, 0x70)] = 9;
            break;
        case 5:
            D_800E98E0[func_800AEC70(0, 0x3C, 0x70)] = 10;
            break;
    }
    D_800D6B30 = 0;
    func_800A5744(0, 0, 0);
}

extern Gfx D_8015A018;
void func_80151CC8_ovl4(Gfx **arg0) {
    gSPDisplayList((*arg0)++, &D_8015A018);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_80151CEC_ovl4(s32 arg0) {
    void *temp_v0;
    void *phi_v0;
    void *phi_a0;

    D_800D6B5C = arg0;
    D_800D6B74 = 1;
    func_80002B88_ovl4();
    func_800A74D8();
    func_80020998_ovl4(0, 0x7800);
    func_800A41B0(0x40000000);
    D_8015A048.unkC = &D_8012EB00 - 0x1900;
    func_80007BA4_ovl4(&D_8015A048);
    D_8015A064.unk10 = &gFrameBuffer - &D_8018EE60;
    phi_v0 = &D_803D6900;
    phi_a0 = &gFrameBuffer;
loop_1:
    phi_v0->unk3F00 = 1;
    phi_a0->unk0 = 1;
    phi_v0->unk3F02 = 1;
    phi_a0->unk2 = 1;
    phi_v0->unk3F04 = 1;
    phi_a0->unk4 = 1;
    phi_v0->unk3F06 = 1;
    temp_v0 = phi_v0 + 8;
    phi_a0->unk6 = 1;
    phi_v0 = temp_v0;
    phi_a0 = phi_a0 + 8;
    if (temp_v0 != &D_803FC100) {
        goto loop_1;
    }
    func_80007380(&D_8015A064, &D_803FC100, &D_8015A064);
    func_800BB3F0();
    return D_800D6B74;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl4/ovl4/func_80151CEC_ovl4.s")
#endif
